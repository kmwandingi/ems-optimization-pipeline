####################################################################################################
# â›…  CLOUD-CODE MASTER PROMPT â€” EMS OPTIMISATION SUITE (v2 â€“ 2025-05-31)
#
#  This prompt is THE canonical specification for the Energy-Management-System repository.
#  It merges every agreement, correction, and extra requirement discussed so far, expanded
#  for completeness.  Follow it verbatim.  Where code already exists, patch minimally;
#  where code is missing, create it.  Keep the repo tiny, deterministic, and academic-grade.
#
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# REPO ROOT STRUCTURE  (do NOT add large new folders)
# â”œâ”€â”€ scripts/
# â”‚     build_duckdb.py            # Phase-0 â€“ creates views only, zero-copy
# â”‚     common.py                  # ALL helper functions cloned from notebooks/utils/helper.py
# â”‚     01_eda.py                  # Exploratory analysis & fleet context
# â”‚     02_run.py                  # All optimisation experiments
# â”‚     compare_modes.py           # Optional fleet-level visual comparison
# â”œâ”€â”€ notebooks/agents/            # KEEP logic; bug-fix only with CHANGELOG.md
# â”œâ”€â”€ notebooks/data/              # *_processed_data.parquet  (7 buildings)
# â”œâ”€â”€ notebooks/probabilities/     # device_hourly_probabilities.parquet
# â”œâ”€â”€ notebooks/utils/             # colour palette, device_specs, config
# â”œâ”€â”€ results/
# â”‚     figures/                   # All .png produced by scripts
# â”‚     output/                    # .csv  .json  .md  RESULT_OK.txt
# â””â”€â”€ CHANGELOG.md                 # only if you touch code in notebooks/agents/
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#
# GLOBAL HARD RULES
# 1.  *Never* import notebooks/utils/helper.py.  Instead, cherry-pick the logic into scripts/common.py
# 2.  All data access goes through DuckDB views â€“ NO direct parquet reads after build_duckdb.py
# 3.  Re-use the colour palette from notebooks/utils/config.py (fallback: define once in common.py)
# 4.  Figures: call plt.tight_layout(); plt.close('all')   |   lines â‰¤ 99 chars; file â‰¤ 400 LOC
# 5.  Keep memory â‰¤ 4 GB.  Do not copy data; views are enough.
# 6.  DRY: if a function is repeated â†’ move to common.py
# 7.  Any agent bug-fix: change the single offending line, log in CHANGELOG.md
# 8.  The CI will fail if RESULT_OK.txt is missing or any assertion fails.
#
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# PHASE-0  â€”  BUILD DUCKDB  (scripts/build_duckdb.py)
# â€¢ Creates ems_data.duckdb with read-only *views* for every *_processed_data.parquet
# â€¢ Also registers priors parquet
# â€¢ Must run (once) before any other script.
#
# PHASE-1  â€”  EDA  (scripts/01_eda.py)
# â€¢ For every building view:
#     â€“ preprocess()   â†’ add hour, day, weekday, season columns
#     â€“ summarise()    â†’ kWh/day, mean â‚¬/kWh, PV ratio, data-coverage days
#     â€“ figures:
#         id_hourly.png           stacked mean 24 h load per device
#         id_pv.png               PV-vs-Load scatter if PV exists
#         id_price.png            histogram of price per kWh
# â€¢ Fleet-level figures: fleet_hourly.png, fleet_daily.png, fleet_corr.png
# â€¢ CSV  results/output/building_summary.csv  (+ Markdown twin)
#
# PHASE-2  â€”  EXPERIMENTS  (scripts/02_run.py)
#   CLI
#     python scripts/02_run.py --building <ID>
#                              --mode decentralised|centralised|centralised_phases
#                              --battery on|off   --ev on|off   --validate
#
#   SHARED PREP
#     con   = common.get_con()         # read-only DuckDB
#     df    = con.sql(f"select * from {id}_processed_data").df()
#     full_days        = 24 h complete, real usage
#     hist_days[:10]   = bootstrap train for ProbabilityModelAgent
#     live_days[:10]   = ONLY weekdays, used in centralised_phases production pipeline
#
#   DEVICES
#     device_specs = notebooks/utils/device_specs.py   (import once)
#     Each row drives creation of FlexibleDevice / EVAgent / etc.
#
#   BATTERY & EV
#     BatteryAgent params â†’ notebooks/utils/config.py::BATTERY_PARAMS
#     EVAgent params      â†’ notebooks/utils/config.py::EV_PARAMS  (plus device_specs["ev"])
#     EVAgent is BOTH:
#         * battery-like (SoC, capacity, efficiency)
#         * device-like  (power_rating, probability, allowed_hours)
#     Detect EV column: f"{building_id}_ev" in df
#     Must set ev.must_be_full_by_hour:
#         â€“ if provided by EV_PARAMS
#         â€“ else infer: hour with highest probability of usage (from ProbabilityModelAgent)
#
#   MODES
#     â€¢ decentralised        â€“ optimise each device independently (implement real optimiser!)
#     â€¢ centralised          â€“ single global optimiser for whole 24 h
#     â€¢ centralised_phases   â€“ four 6-h windows (0-6,6-12,12-18,18-24)  â† production
#
#   OPTIMISER  (sketch, implement fully)
#     cost = Î£ kWh Ã— price  (price column in df)
#     constraints: per-device power limits, allowed_hours; grid max_import; battery/EV SoC
#     objective: min(cost) + 0.0005 Ã— battery_degradation â‚¬  (use config.degradation_cost)
#
#   ROLLING LOOP  (centralised_phases)
#     for live day:
#         â€“ assign dev.hour_probability  from ProbabilityModelAgent
#         â€“ run optimiser by phases
#         â€“ save JSON schedule  results/output/{id}_{mode}_sched.json
#         â€“ plot heat-map + price   figures/{id}_{day}_{mode}_heat.png
#         â€“ assertions (see section ASSERTIONS)
#         â€“ online retrain ProbabilityModelAgent with actual usage
#
#   OUTPUT per run
#     â€¢ KPI row appended to results/output/kpis_{id}_{mode}_bat{on/off}_ev{on/off}.csv
#     â€¢ Battery SoC trajectory figure
#     â€¢ EV SoC trajectory if ev_on
#     â€¢ Cost bar plot  '{id}_bat{on/off}_ev{on/off}_cost_bar.png'
#
#   AFTER ALL RUNS for a building
#     â€“ cumulative_savings.png
#     â€“ battery_cycles histogram
#
#   COMPARISON SCRIPT (scripts/compare_modes.py)
#     â€“ loads KPI CSVs
#     â€“ draws multi-mode line plot & scatter diagnostics
#
# ASSERTIONS  (all in scripts/common.py)
#   assert_energy_balance(day_df, battery, ev, tol=0.1 kWh)
#   assert_battery_limits(battery)
#   assert_ev_window(ev, schedule)
#   assert_ev_departure(ev, end_soc)
#   assert_savings(kpi_row, min_savings_pct=0)
#   Any failure â‡’ RuntimeError, skip day, record in RESULT_OK.txt
#
# KPI & TABLES  (write CSV + .md twin)
#   T1 building_summary.csv                       (from EDA)
#   T2 kpis_<building>.csv                        (+ ev_energy_kWh, ev_target_met, â€¦)
#   T3 fleet_kpis.csv
#   T4 prob_llh.csv  (pre- vs post-training log-likelihood)
#   plus fleet_ev_kpis.csv
#
# FIGURE CATALOGUE  (must be produced, see prev list + F7-F14 additions)
#   F7  orig_vs_opt line            {id}_{day}_orig_vs_opt.png
#   F8  cumulative_savings          {id}_cumulative_savings.png
#   F9  battery_cycle_hist          {id}_{mode}_battery_cycles.png
#   F10 fleet PV vs savings scatter fleet_pv_vs_savings.png
#   F11 EV heat-map                 {id}_{day}_{mode}_ev_heat.png
#   F12 EV SoC trajectory           {id}_ev_soc_trajectory.png
#   F13 fleet EV gap histogram      fleet_ev_gap_hist.png
#   F14 fleet EV cost vs savings    fleet_ev_cost_vs_savings.png
#
# RESULT HEALTH REPORT
#   After all buildings processed:
#     â€¢ generate results/output/RESULTS_OK.txt containing:
#         total runtime, max imbalance, days dropped, meanÂ±CI savings%
#
# COLOUR PALETTE
#   Load dict COLOURS from notebooks/utils/config.py
#   Keys USED: Original, Decentralised_NoBatt, Decentralised_WithBatt,
#              Centralised, Centralised_Phases, Battery, EV, PV, Price
#
# TIPS & GUARDRAILS
# â€¢ Use cvxpy or pulp for optimisation; keep solver GLPK/ECOS for <4 GB memory
# â€¢ To speed: cache price vector per day
# â€¢ Tight_layout warnings are fine; no need to suppress
# â€¢ test data quickly: DE_KN_residential4 (has PV+EV), DE_KN_industrial3 (big load)
#
# CI EXIT CONDITIONS (auto-grader)
#   âœ“ build_duckdb.py runs
#   âœ“ all scripts produce listed artefacts
#   âœ“ RESULT_OK.txt present
#   âœ“ every centralised_phases savings_abs â‰¥ 0
#   âœ“ no parquet read outside DuckDB
#
# ROLE & MINDSET FOR CLOUD CODE
#   You are an optimisation engineer.  Respect existing agent APIs.
#   Patch tiny bugs only.  Keep code short, typed, commented.
#   When in doubt: mimic notebooks/utils/helper.py logic, but place in common.py.
#
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸš€  BEGIN IMPLEMENTATION NOW â€” no further questions, no shortcuts.
####################################################################################################

 **Begin.*

remove insatnces where you name things like "real" thi or that. also       â”‚
â”‚   pipeline a or b need to be more explicit so we know what is being spoken   â”‚
â”‚   about. clean this uo in the h=whole code! DO all tests agsain and again    â”‚
â”‚   with scenarios to ensure your cleanup does  not break anyhting!            
